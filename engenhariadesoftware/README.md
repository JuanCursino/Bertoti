# Atividade 1

Withain Google, we sometimes say, ‚ÄúSoftware engineering is programming integrated over time.‚Äù Programming is certainly a significant part of software : engineering after all, programming is how you generate new software in the first place. If you accept this distinction, it also becomesnsion to programming. Cubes clear that we might need to delineate between programming tasks (development) and software engineering tasks (development, modification, mmimaintenance). The addition of time adds an important new dimeension to programming.


We see three critical differences between programming and software engineering: time, scale, and the trade-offs at play. On a software engineering project, engineers need to be more concerned with the passage of time and the eventual need for change. In a software engineering organization, we need to be more concerned about scale and efficiency, both for the software we produce as well as for the organization that is producing it. Finally, as software engineers, we are asked to make more complex decisions with higher-stakes outcomes, often based on imprecise estimates of time and growth.




- √â a integra√ß√£o do processo de programa√ß√£o ao longo do tempo. √â a modo de como novos softwares s√£o criados, desenvolvidos, modificados e mantidos. Engenharia de software envolve n√£o √© s√≥ a programa√ß√£o em si, mas tamb√©m a considera√ß√£o do tempo, escala e dos trade-offs envolvidos no desenvolvimento. Os engenheiros de software precisam se preocupar com a passagem do tempo, a necessidade de mudan√ßas, a efici√™ncia do software e da organiza√ß√£o que o produz, e tomar decis√µes complexas com consequ√™ncias de alto risco, muitas vezes baseadas em estimativas imprecisas.

Escala: Refere-se √† capacidade do software de expandir-se conforme a demanda, tanto em termos de usu√°rios quanto de funcionalidades. Um software escal√°vel √© capaz de crescer sem comprometer o desempenho, podendo lidar com um aumento significativo no n√∫mero de usu√°rios e na quantidade de dados. Por exemplo, um site de com√©rcio eletr√¥nico deve ser capaz de suportar milh√µes de usu√°rios e produtos sem afetar a velocidade ou a qualidade da experi√™ncia do usu√°rio.

Tempo: Inclui diversos aspectos, como o tempo necess√°rio para desenvolver o software, a rapidez com que ele responde √†s solicita√ß√µes dos usu√°rios e o tempo dedicado √† manuten√ß√£o ap√≥s o lan√ßamento. Gerenciar eficientemente o tempo de desenvolvimento e manuten√ß√£o √© essencial para garantir que o software seja entregue no prazo e mantenha sua efic√°cia ao longo do tempo.

Trade-offs: S√£o decis√µes dif√≠ceis que os engenheiros de software precisam tomar ao desenvolver um produto. Por exemplo, melhorar o desempenho do software pode exigir investimentos adicionais em hardware ou otimiza√ß√µes complexas, enquanto adicionar muitas funcionalidades pode aumentar a complexidade do software e torn√°-lo mais dif√≠cil de manter. Encontrar o equil√≠brio certo entre diferentes objetivos, como desempenho, custo e facilidade de uso, √© fundamental para o sucesso do projeto.



# Atividade 2 

1.Java

Vantagens: Java √© uma linguagem de programa√ß√£o orientada a objetos que fornece forte seguran√ßa e portabilidade de c√≥digo. Rode em qualquer sistema operacional que possua uma m√°quina virtual Java. Possui uma vasta comunidade de desenvolvedores e uma ampla gama de bibliotecas e frameworks dispon√≠veis. Java √© uma linguagem compilada, o que pode resultar em melhor performance em aplica√ß√µes de alta demanda de processamento.

Desvantagens: Java pode ser mais dif√≠cil de aprender do que linguagens como Python, devido √† sua sintaxe mais complexa e aos conceitos de programa√ß√£o orientada a objetos. O processo de compila√ß√£o em Java pode ser mais demorado do que em linguagens interpretadas, o que pode afetar a produtividade. Al√©m disso, a tipagem est√°tica em Java pode resultar em mais linhas de c√≥digo para realizar tarefas simples.

2.C++

Vantagens: C++ √© uma linguagem de programa√ß√£o de alto desempenho, amplamente utilizada em aplica√ß√µes que exigem controle direto sobre o hardware. √â uma linguagem compilada que oferece um alto n√≠vel de controle sobre a mem√≥ria e recursos do sistema. C++ √© conhecido por sua efici√™ncia e velocidade, sendo amplamente utilizado em aplica√ß√µes como jogos e sistemas de tempo real.

Desvantagens: C++ pode ser mais complexo e dif√≠cil de aprender do que outras linguagens de programa√ß√£o devido √† sua sintaxe e conceitos avan√ßados. O gerenciamento manual de mem√≥ria em C++ pode levar a erros de aloca√ß√£o e vazamento de mem√≥ria, o que pode ser dif√≠cil de depurar. Al√©m disso, a falta de uma biblioteca padr√£o abrangente em C++ pode exigir a utiliza√ß√£o de bibliotecas externas para tarefas comuns.

3.Ruby

Vantagens: Ruby √© uma linguagem de programa√ß√£o din√¢mica e de f√°cil aprendizado, com uma sintaxe elegante e expressiva. Possui uma ampla variedade de frameworks populares, como Ruby on Rails, que aceleram o desenvolvimento de aplica√ß√µes web. Ruby √© uma linguagem interpretada, o que torna o desenvolvimento e teste mais r√°pidos. Al√©m disso, Ruby promove a filosofia de programa√ß√£o orientada a objetos e permite a escrita de c√≥digo limpo e modular.

Desvantagens: A performance de Ruby pode ser inferior a outras linguagens devido √† sua natureza interpretada, o que pode ser um problema em aplica√ß√µes de alta demanda de processamento. A comunidade de desenvolvedores de Ruby √© menor em compara√ß√£o com outras linguagens mais populares, o que pode resultar em menos recursos e documenta√ß√£o dispon√≠veis. Al√©m disso, a tipagem din√¢mica em Ruby pode levar a erros de execu√ß√£o que s√≥ s√£o detectados durante a execu√ß√£o do programa.



# Atividade 3 üëç

https://docs.google.com/presentation/d/1Lmad2CS1pM1UycQpYn6FiDm2NsEO6CVSchym65tuk4U/edit#slide=id.g1f2b4e971a0_0_139

## Slides da atividade :+1:

**25 Seguran√ßa de dados (Ex: Firewall):**
- Simplicity: ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê
A estrutura simples sugere que as informa√ß√µes do usu√°rio ser√£o protegidas e criptografadas a cada intera√ß√£o.
- Fault tolerance: ‚≠ê
A baixa toler√¢ncia a falhas pode ser uma preocupa√ß√£o em termos de seguran√ßa dos dados, pois pode n√£o haver muitos mecanismos para lidar com falhas.

**26 Sistema operacional (Ex: LINUX):**
- Overall cost: ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê
Estrutura microcare para sistema operacional pode resultar em baixos custos gerais.
- Fault tolerance: ‚≠ê
A baixa toler√¢ncia a falhas pode ser uma desvantagem, especialmente em ambientes cr√≠ticos.

**27 Software de servi√ßo (Ex: Netflix/Office):**
- Reliability: ‚≠ê‚≠ê‚≠ê‚≠ê
Espera-se um bom n√≠vel de confiabilidade, especialmente em servi√ßos como Netflix ou Office.
- Elasticity: ‚≠ê‚≠ê
A capacidade de se adaptar a varia√ß√µes de demanda pode n√£o ser t√£o alta, mas ainda √© consider√°vel.

**28 Pix (ou outros servi√ßos monet√°rios):**
- Scalability: ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê
A estrutura √© altamente escal√°vel, especialmente importante para servi√ßos financeiros.
- Simplicity: ‚≠ê
Pode ser menos simples devido aos rigorosos requisitos de seguran√ßa e conformidade.

**29 Servi√ßo de Nuvem (Ex: AWS):**
- Scalability: ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê
Alta escalabilidade √© uma caracter√≠stica essencial de servi√ßos de nuvem como AWS.
- Simplicity: ‚≠ê
Embora seja altamente escal√°vel, a complexidade pode dificultar o uso para usu√°rios inexperientes.


# Atividade 4

**Loja de celulares**
- Layered Architecture Style (Arquitetura em Camadas):

- Simplicity (Simplicidade): ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê
A Arquitetura em Camadas √© conhecida por sua simplicidade de compreens√£o e implementa√ß√£o, o que a torna ideal para muitos casos de uso.
- Overall cost (Custo geral): ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê
Geralmente, a implementa√ß√£o e manuten√ß√£o de uma arquitetura em camadas s√£o mais econ√¥micas, pois √© menos complexa e mais f√°cil de gerenciar.
- Performance (Desempenho): ‚≠ê
Em termos de desempenho, a Arquitetura em Camadas pode n√£o ser a mais otimizada, pois cada solicita√ß√£o deve passar por v√°rias camadas, o que pode adicionar lat√™ncia.
- Scalability (Escalabilidade): ‚≠ê
A escalabilidade da Arquitetura em Camadas pode ser limitada, especialmente se n√£o for projetada com escalabilidade em mente desde o in√≠cio.

# Atividade 5, 6 e 7

Est√£o no c√≥digo!





Arrumar atividade 1, 2,3 e 5
Deixa mais detalhadado as 3 primeiras, e mudar pra seta no segundo
